part of '../scene.dart';

final class _PuzzleEntity {
  int useIdScene = -1; // id of the used scene
  int useIdSeries = -1; // id of the used series
  int diagonal = -1;
  // Puzzle animation duration
  final durationFullAnimation = 200; // 600; // 600;
  final durationDiagonalAnimation = 300; //1200; // 1200;
  // Working window size
  final sizePuzzle = _SizePuzzlePanel();
  // The unique key of a correctly folded puzzle
  final keysPuzzle = _KeysPuzzle();
  // final ImageScene image;
  // final int typeTree;

  // final UserScene user;

  // Checking if the user is running the previous scene for the game
  bool checkingThisIsGameWithPreviousScene({required int idNewSeries, required int idNewScene}) {
    // true - if the new game is launched with the parameters of the old scene
    return (idNewSeries == useIdSeries && idNewScene == useIdScene && keysPuzzle.isKeysPuzzleEqual());
  }

  set(SceneEntity data) {
    useIdScene = data.idScene;
    useIdSeries = data.idSeries;
    diagonal = data.hardLevel;
  }

  // Old (previously loaded) data will be returned if idScene has not changed
  bool isOldSceneUsed(int idNewSeires) => useIdScene == idNewSeires;
}

final class _SizePuzzlePanel {
  double width = 0;
  double height = 0;

  // Start new game - set size of window
  runNewGame({required double w, required double h}) {
    width = w;
    height = h;
  }
}

final class _KeysPuzzle {
  // The unique key of a correctly folded puzzle;
  // Used to check against the key folded by the user to determine victory
  String _correctKeysPuzzleWin = '';
  // Game keys that the user folds during the game
  final _currentGameKeysPuzzleWin = <int>[];

  // Start new game
  runNewGame(String grid) {
    // Formation of the correct scene key. The user wins if [_currentGameKeysPuzzleWin] == [countKeysGrid]
    final countKeysGrid = grid.split('x').map((e) => int.parse(e)).reduce((xCount, yCount) => xCount * yCount);
    _correctKeysPuzzleWin = List.generate(countKeysGrid, (index) => index + 1).join('-');
  }

  // Checking the correct key and the key generated by the user after each swipe
  bool isKeysPuzzleEqual() => _correctKeysPuzzleWin == _currentGameKeysPuzzleWin.join('-');
}
/// Image of scene
// final class ImageScene {
//   final int idImage;
//   final String url;
//   final int typeView;
//   final TypeSourceImage typeSourceImage;

//   ImageScene({
//     required this.idImage,
//     required this.url,
//     required this.typeView,
//   }) : typeSourceImage = _setTypeSourceImage(url);

//   // Setting the image source
//   static _setTypeSourceImage(String url) {
//     if (url.startsWith('http')) {
//       return TypeSourceImage.server;
//     } else {
//       return TypeSourceImage.asset;
//     }
//   }
// }

// /// User data of scene
// final class UserScene {
//   final AuthorUserScene author;
//   final StateViewUserScene stat;

//   UserScene({
//     required this.author,
//     required this.stat,
//   });
// }

// /// User as author of scene
// final class AuthorUserScene {
//   final int idApp;

//   AuthorUserScene(this.idApp);
// }

// /// Current user statistics in scene
// final class StateViewUserScene {
//   final int xp;
//   final int completed;

//   StateViewUserScene({
//     required this.xp,
//     required this.completed,
//   });
// }

// /// General statistics of the series
// final class StatScene {
//   final int recordTime;
//   final int countUsers;

//   StatScene({
//     required this.recordTime,
//     required this.countUsers,
//   });
// }
